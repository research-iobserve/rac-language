/**
 * generated by Xtext
 */
package org.iobserve.rac.constraint.scoping;

import com.google.common.base.Objects;
import de.cau.cs.se.instrumentation.rl.recordLang.Property;
import de.cau.cs.se.instrumentation.rl.recordLang.RecordType;
import de.cau.cs.se.instrumentation.rl.recordLang.Type;
import de.cau.cs.se.instrumentation.rl.validation.PropertyEvaluation;
import java.util.List;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.xtext.scoping.IScope;
import org.eclipse.xtext.scoping.Scopes;
import org.eclipse.xtext.scoping.impl.AbstractDeclarativeScopeProvider;
import org.iobserve.rac.constraint.constraintLang.ConcreteType;
import org.iobserve.rac.constraint.constraintLang.ConstraintExpression;
import org.iobserve.rac.constraint.constraintLang.ParameterExpression;
import org.iobserve.rac.constraint.constraintLang.PropertyConstraint;
import org.iobserve.rac.constraint.constraintLang.RecordTypeModifier;
import org.iobserve.rac.constraint.constraintLang.RecordTypeSelection;
import org.iobserve.rac.constraint.constraintLang.SelectInput;
import org.iobserve.rac.constraint.constraintLang.TypeSelection;

/**
 * This class contains custom scoping description.
 * 
 * see : http://www.eclipse.org/Xtext/documentation.html#scoping
 * on how and when to use it
 */
@SuppressWarnings("all")
public class ConstraintLangScopeProvider extends AbstractDeclarativeScopeProvider {
  /**
   * Create scope for property names in filter property scopes.
   */
  public IScope scope_PropertyConstraint_name(final PropertyConstraint ctx, final EReference reference) {
    EObject _parentConstraintExpression = this.parentConstraintExpression(ctx);
    TypeSelection _typeSelection = null;
    if (((ConstraintExpression) _parentConstraintExpression)!=null) {
      _typeSelection=((ConstraintExpression) _parentConstraintExpression).getTypeSelection();
    }
    final TypeSelection typeSelection = _typeSelection;
    List<Property> _collectProperties = null;
    if (typeSelection!=null) {
      _collectProperties=this.collectProperties(typeSelection);
    }
    final List<Property> properties = _collectProperties;
    return Scopes.scopeFor(properties);
  }
  
  /**
   * Create scope for property names of an input source in a select expression.
   */
  public IScope scope_ParameterExpression_propertyReference(final ParameterExpression ctx, final EReference reference) {
    SelectInput _input = ctx.getInput();
    boolean _notEquals = (!Objects.equal(_input, null));
    if (_notEquals) {
      SelectInput _input_1 = ctx.getInput();
      RecordType _recordType = _input_1.getRecordType();
      List<Property> _collectAllDataProperties = PropertyEvaluation.collectAllDataProperties(_recordType);
      return Scopes.scopeFor(_collectAllDataProperties);
    } else {
      EObject _parentSelectInput = this.parentSelectInput(ctx);
      final SelectInput node = ((SelectInput) _parentSelectInput);
      RecordType _recordType_1 = node.getRecordType();
      List<Property> _collectAllDataProperties_1 = PropertyEvaluation.collectAllDataProperties(_recordType_1);
      return Scopes.scopeFor(_collectAllDataProperties_1);
    }
  }
  
  /**
   * Find all types defined by
   */
  private List<Property> collectProperties(final TypeSelection selection) {
    EList<Property> _switchResult = null;
    boolean _matched = false;
    if (!_matched) {
      if (selection instanceof ConcreteType) {
        _matched=true;
        Type _type = ((ConcreteType)selection).getType();
        _switchResult = _type.getProperties();
      }
    }
    if (!_matched) {
      if (selection instanceof RecordTypeSelection) {
        RecordTypeModifier _modifier = ((RecordTypeSelection)selection).getModifier();
        boolean _equals = Objects.equal(_modifier, RecordTypeModifier.SUPER);
        if (_equals) {
          _matched=true;
          RecordType _type = ((RecordTypeSelection)selection).getType();
          RecordType _parent = _type.getParent();
          EList<Property> _properties = null;
          if (_parent!=null) {
            _properties=_parent.getProperties();
          }
          _switchResult = _properties;
        }
      }
    }
    if (!_matched) {
      if (selection instanceof RecordTypeSelection) {
        RecordTypeModifier _modifier = ((RecordTypeSelection)selection).getModifier();
        boolean _equals = Objects.equal(_modifier, RecordTypeModifier.EXTENDS);
        if (_equals) {
          _matched=true;
          RecordType _type = ((RecordTypeSelection)selection).getType();
          _switchResult = _type.getProperties();
        }
      }
    }
    if (!_matched) {
      throw new UnsupportedOperationException("Support for this language feature has not been implemented.");
    }
    return _switchResult;
  }
  
  /**
   * find the parent or parents parent or ... of the given object matching the type.
   */
  private EObject parentConstraintExpression(final EObject object) {
    boolean _equals = Objects.equal(object, null);
    if (_equals) {
      return null;
    } else {
      EObject _eContainer = object.eContainer();
      if ((_eContainer instanceof ConstraintExpression)) {
        return object.eContainer();
      } else {
        EObject _eContainer_1 = object.eContainer();
        return this.parentConstraintExpression(_eContainer_1);
      }
    }
  }
  
  private EObject parentSelectInput(final EObject object) {
    boolean _equals = Objects.equal(object, null);
    if (_equals) {
      return null;
    } else {
      EObject _eContainer = object.eContainer();
      if ((_eContainer instanceof SelectInput)) {
        return object.eContainer();
      } else {
        EObject _eContainer_1 = object.eContainer();
        return this.parentSelectInput(_eContainer_1);
      }
    }
  }
}
