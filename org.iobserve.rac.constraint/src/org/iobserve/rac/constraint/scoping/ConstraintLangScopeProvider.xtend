/*
 * generated by Xtext
 */
package org.iobserve.rac.constraint.scoping

import de.cau.cs.se.instrumentation.rl.recordLang.Property
import java.util.List
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EReference
import org.eclipse.xtext.scoping.Scopes
import org.eclipse.xtext.scoping.impl.AbstractDeclarativeScopeProvider
import org.iobserve.rac.constraint.constraintLang.ConcreteType
import org.iobserve.rac.constraint.constraintLang.ConstraintExpression
import org.iobserve.rac.constraint.constraintLang.PropertyConstraint
import org.iobserve.rac.constraint.constraintLang.RecordTypeModifier
import org.iobserve.rac.constraint.constraintLang.RecordTypeSelection
import org.iobserve.rac.constraint.constraintLang.TypeSelection
import org.iobserve.rac.constraint.constraintLang.ParameterExpression
import de.cau.cs.se.instrumentation.rl.validation.PropertyEvaluation
import org.iobserve.rac.constraint.constraintLang.SelectInput

/**
 * This class contains custom scoping description.
 * 
 * see : http://www.eclipse.org/Xtext/documentation.html#scoping
 * on how and when to use it 
 *
 */
class ConstraintLangScopeProvider extends AbstractDeclarativeScopeProvider {

	/**
	 * Create scope for property names in filter property scopes. 
	 */
	def scope_PropertyConstraint_name(PropertyConstraint ctx, EReference reference) {
		val typeSelection = (ctx.parentConstraintExpression as ConstraintExpression)?.typeSelection
		// TODO this is not sufficient as it ignores type inheritance, copy from RecordLang
		val properties = typeSelection?.collectProperties 
		return Scopes.scopeFor(properties)
	}
	
	/**
	 * Create scope for property names of an input source in a select expression.
	 */
	def scope_ParameterExpression_propertyReference(ParameterExpression ctx, EReference reference) {
		if (ctx.input != null) {
			// TODO here add collect all CONSTANTS too ???
			return Scopes.scopeFor(PropertyEvaluation::collectAllDataProperties(ctx.input.recordType))
		} else {
			val node = ctx.parentSelectInput as SelectInput
			return Scopes.scopeFor(PropertyEvaluation::collectAllDataProperties(node.recordType))
		} 
	}
	
	/**
	 * Find all types defined by 
	 */
	private def List<Property> collectProperties(TypeSelection selection) {
		switch(selection) {
			ConcreteType: selection.type.properties
			RecordTypeSelection case selection.modifier == RecordTypeModifier.SUPER: selection.type.parent?.properties
			RecordTypeSelection case selection.modifier == RecordTypeModifier.EXTENDS: selection.type.properties
			default:
				throw new UnsupportedOperationException("Support for this language feature has not been implemented.")
		}
	}
	
	/**
	 * find the parent or parents parent or ... of the given object matching the type.
	 */
	private def EObject parentConstraintExpression(EObject object) {
		if (object == null)
			return null
		else if (object.eContainer instanceof ConstraintExpression)
			return object.eContainer
		else
			return parentConstraintExpression(object.eContainer)
	}
	
	
	private def EObject parentSelectInput(EObject object) {
		if (object == null)
			return null
		else if (object.eContainer instanceof SelectInput)
			return object.eContainer
		else
			return parentSelectInput(object.eContainer)
	}
	
}

