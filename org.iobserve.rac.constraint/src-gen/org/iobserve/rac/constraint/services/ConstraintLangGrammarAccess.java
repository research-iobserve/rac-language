/*
* generated by Xtext
*/
package org.iobserve.rac.constraint.services;

import com.google.inject.Singleton;
import com.google.inject.Inject;

import java.util.List;

import org.eclipse.xtext.*;
import org.eclipse.xtext.service.GrammarProvider;
import org.eclipse.xtext.service.AbstractElementFinder.*;

import org.eclipse.xtext.common.services.TerminalsGrammarAccess;

@Singleton
public class ConstraintLangGrammarAccess extends AbstractGrammarElementFinder {
	
	
	public class ModelElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Model");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cPackageKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameQualifiedNameParserRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Assignment cImportsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cImportsImportParserRuleCall_2_0 = (RuleCall)cImportsAssignment_2.eContents().get(0);
		private final Assignment cOperationsAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cOperationsOperationParserRuleCall_3_0 = (RuleCall)cOperationsAssignment_3.eContents().get(0);
		
		//Model:
		//	"package" name=QualifiedName imports+=Import* operations+=Operation*;
		public ParserRule getRule() { return rule; }

		//"package" name=QualifiedName imports+=Import* operations+=Operation*
		public Group getGroup() { return cGroup; }

		//"package"
		public Keyword getPackageKeyword_0() { return cPackageKeyword_0; }

		//name=QualifiedName
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//QualifiedName
		public RuleCall getNameQualifiedNameParserRuleCall_1_0() { return cNameQualifiedNameParserRuleCall_1_0; }

		//imports+=Import*
		public Assignment getImportsAssignment_2() { return cImportsAssignment_2; }

		//Import
		public RuleCall getImportsImportParserRuleCall_2_0() { return cImportsImportParserRuleCall_2_0; }

		//operations+=Operation*
		public Assignment getOperationsAssignment_3() { return cOperationsAssignment_3; }

		//Operation
		public RuleCall getOperationsOperationParserRuleCall_3_0() { return cOperationsOperationParserRuleCall_3_0; }
	}

	public class ImportElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Import");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cImportKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cImportedNamespaceAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cImportedNamespaceQualifiedNameWithWildcardParserRuleCall_1_0 = (RuleCall)cImportedNamespaceAssignment_1.eContents().get(0);
		
		//Import:
		//	"import" importedNamespace=QualifiedNameWithWildcard;
		public ParserRule getRule() { return rule; }

		//"import" importedNamespace=QualifiedNameWithWildcard
		public Group getGroup() { return cGroup; }

		//"import"
		public Keyword getImportKeyword_0() { return cImportKeyword_0; }

		//importedNamespace=QualifiedNameWithWildcard
		public Assignment getImportedNamespaceAssignment_1() { return cImportedNamespaceAssignment_1; }

		//QualifiedNameWithWildcard
		public RuleCall getImportedNamespaceQualifiedNameWithWildcardParserRuleCall_1_0() { return cImportedNamespaceQualifiedNameWithWildcardParserRuleCall_1_0; }
	}

	public class OperationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Operation");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cFilterParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cSelectionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//// -----------------------------------
		//// filter, selection and composition
		//Operation:
		//	Filter | Selection;
		public ParserRule getRule() { return rule; }

		//Filter | Selection
		public Alternatives getAlternatives() { return cAlternatives; }

		//Filter
		public RuleCall getFilterParserRuleCall_0() { return cFilterParserRuleCall_0; }

		//Selection
		public RuleCall getSelectionParserRuleCall_1() { return cSelectionParserRuleCall_1; }
	}

	public class SelectionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Selection");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cSelectKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Assignment cSourceReferenceAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cSourceReferenceSourceReferenceParserRuleCall_2_0 = (RuleCall)cSourceReferenceAssignment_2.eContents().get(0);
		private final Keyword cColonKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cInputsAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cInputsSelectInputParserRuleCall_4_0 = (RuleCall)cInputsAssignment_4.eContents().get(0);
		private final Group cGroup_5 = (Group)cGroup.eContents().get(5);
		private final Keyword cCommaKeyword_5_0 = (Keyword)cGroup_5.eContents().get(0);
		private final Assignment cInputsAssignment_5_1 = (Assignment)cGroup_5.eContents().get(1);
		private final RuleCall cInputsSelectInputParserRuleCall_5_1_0 = (RuleCall)cInputsAssignment_5_1.eContents().get(0);
		private final Keyword cStoreKeyword_6 = (Keyword)cGroup.eContents().get(6);
		private final Assignment cRecordTypeAssignment_7 = (Assignment)cGroup.eContents().get(7);
		private final CrossReference cRecordTypeRecordTypeCrossReference_7_0 = (CrossReference)cRecordTypeAssignment_7.eContents().get(0);
		private final RuleCall cRecordTypeRecordTypeIDTerminalRuleCall_7_0_1 = (RuleCall)cRecordTypeRecordTypeCrossReference_7_0.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_8 = (Keyword)cGroup.eContents().get(8);
		private final Assignment cParemterExpressionsAssignment_9 = (Assignment)cGroup.eContents().get(9);
		private final RuleCall cParemterExpressionsParameterExpressionParserRuleCall_9_0 = (RuleCall)cParemterExpressionsAssignment_9.eContents().get(0);
		private final Group cGroup_10 = (Group)cGroup.eContents().get(10);
		private final Keyword cCommaKeyword_10_0 = (Keyword)cGroup_10.eContents().get(0);
		private final Assignment cParemterExpressionsAssignment_10_1 = (Assignment)cGroup_10.eContents().get(1);
		private final RuleCall cParemterExpressionsParameterExpressionParserRuleCall_10_1_0 = (RuleCall)cParemterExpressionsAssignment_10_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_11 = (Keyword)cGroup.eContents().get(11);
		
		//// ---------------------
		//// selection
		//Selection:
		//	"select" name=ID sourceReference=SourceReference ":" inputs+=SelectInput ("," inputs+=SelectInput)* "store"
		//	recordType=[record::RecordType] "(" paremterExpressions+=ParameterExpression (","
		//	paremterExpressions+=ParameterExpression)* ")";
		public ParserRule getRule() { return rule; }

		//"select" name=ID sourceReference=SourceReference ":" inputs+=SelectInput ("," inputs+=SelectInput)* "store"
		//recordType=[record::RecordType] "(" paremterExpressions+=ParameterExpression (","
		//paremterExpressions+=ParameterExpression)* ")"
		public Group getGroup() { return cGroup; }

		//"select"
		public Keyword getSelectKeyword_0() { return cSelectKeyword_0; }

		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }

		//sourceReference=SourceReference
		public Assignment getSourceReferenceAssignment_2() { return cSourceReferenceAssignment_2; }

		//SourceReference
		public RuleCall getSourceReferenceSourceReferenceParserRuleCall_2_0() { return cSourceReferenceSourceReferenceParserRuleCall_2_0; }

		//":"
		public Keyword getColonKeyword_3() { return cColonKeyword_3; }

		//inputs+=SelectInput
		public Assignment getInputsAssignment_4() { return cInputsAssignment_4; }

		//SelectInput
		public RuleCall getInputsSelectInputParserRuleCall_4_0() { return cInputsSelectInputParserRuleCall_4_0; }

		//("," inputs+=SelectInput)*
		public Group getGroup_5() { return cGroup_5; }

		//","
		public Keyword getCommaKeyword_5_0() { return cCommaKeyword_5_0; }

		//inputs+=SelectInput
		public Assignment getInputsAssignment_5_1() { return cInputsAssignment_5_1; }

		//SelectInput
		public RuleCall getInputsSelectInputParserRuleCall_5_1_0() { return cInputsSelectInputParserRuleCall_5_1_0; }

		//"store"
		public Keyword getStoreKeyword_6() { return cStoreKeyword_6; }

		//recordType=[record::RecordType]
		public Assignment getRecordTypeAssignment_7() { return cRecordTypeAssignment_7; }

		//[record::RecordType]
		public CrossReference getRecordTypeRecordTypeCrossReference_7_0() { return cRecordTypeRecordTypeCrossReference_7_0; }

		//ID
		public RuleCall getRecordTypeRecordTypeIDTerminalRuleCall_7_0_1() { return cRecordTypeRecordTypeIDTerminalRuleCall_7_0_1; }

		//"("
		public Keyword getLeftParenthesisKeyword_8() { return cLeftParenthesisKeyword_8; }

		//paremterExpressions+=ParameterExpression
		public Assignment getParemterExpressionsAssignment_9() { return cParemterExpressionsAssignment_9; }

		//ParameterExpression
		public RuleCall getParemterExpressionsParameterExpressionParserRuleCall_9_0() { return cParemterExpressionsParameterExpressionParserRuleCall_9_0; }

		//("," paremterExpressions+=ParameterExpression)*
		public Group getGroup_10() { return cGroup_10; }

		//","
		public Keyword getCommaKeyword_10_0() { return cCommaKeyword_10_0; }

		//paremterExpressions+=ParameterExpression
		public Assignment getParemterExpressionsAssignment_10_1() { return cParemterExpressionsAssignment_10_1; }

		//ParameterExpression
		public RuleCall getParemterExpressionsParameterExpressionParserRuleCall_10_1_0() { return cParemterExpressionsParameterExpressionParserRuleCall_10_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_11() { return cRightParenthesisKeyword_11; }
	}

	public class SelectInputElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SelectInput");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cRecordTypeAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cRecordTypeRecordTypeCrossReference_0_0 = (CrossReference)cRecordTypeAssignment_0.eContents().get(0);
		private final RuleCall cRecordTypeRecordTypeIDTerminalRuleCall_0_0_1 = (RuleCall)cRecordTypeRecordTypeCrossReference_0_0.eContents().get(1);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cColonKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cSelectConstraintAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cSelectConstraintSelectConstaintExpressionParserRuleCall_2_1_0 = (RuleCall)cSelectConstraintAssignment_2_1.eContents().get(0);
		
		//SelectInput:
		//	recordType=[record::RecordType] name=ID (":" selectConstraint=SelectConstaintExpression)?;
		public ParserRule getRule() { return rule; }

		//recordType=[record::RecordType] name=ID (":" selectConstraint=SelectConstaintExpression)?
		public Group getGroup() { return cGroup; }

		//recordType=[record::RecordType]
		public Assignment getRecordTypeAssignment_0() { return cRecordTypeAssignment_0; }

		//[record::RecordType]
		public CrossReference getRecordTypeRecordTypeCrossReference_0_0() { return cRecordTypeRecordTypeCrossReference_0_0; }

		//ID
		public RuleCall getRecordTypeRecordTypeIDTerminalRuleCall_0_0_1() { return cRecordTypeRecordTypeIDTerminalRuleCall_0_0_1; }

		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }

		//(":" selectConstraint=SelectConstaintExpression)?
		public Group getGroup_2() { return cGroup_2; }

		//":"
		public Keyword getColonKeyword_2_0() { return cColonKeyword_2_0; }

		//selectConstraint=SelectConstaintExpression
		public Assignment getSelectConstraintAssignment_2_1() { return cSelectConstraintAssignment_2_1; }

		//SelectConstaintExpression
		public RuleCall getSelectConstraintSelectConstaintExpressionParserRuleCall_2_1_0() { return cSelectConstraintSelectConstaintExpressionParserRuleCall_2_1_0; }
	}

	public class SelectConstaintExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SelectConstaintExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cBasicSelectConstraintParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cGroup_1.eContents().get(0);
		private final Group cGroup_1_0_0 = (Group)cGroup_1_0.eContents().get(0);
		private final Action cSelectConstaintExpressionLeftAction_1_0_0_0 = (Action)cGroup_1_0_0.eContents().get(0);
		private final Assignment cOperatorAssignment_1_0_0_1 = (Assignment)cGroup_1_0_0.eContents().get(1);
		private final RuleCall cOperatorLogicOperatorEnumRuleCall_1_0_0_1_0 = (RuleCall)cOperatorAssignment_1_0_0_1.eContents().get(0);
		private final Assignment cRightAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cRightSelectConstaintExpressionParserRuleCall_1_1_0 = (RuleCall)cRightAssignment_1_1.eContents().get(0);
		
		//SelectConstaintExpression:
		//	BasicSelectConstraint (=> ({SelectConstaintExpression.left=current} operator=LogicOperator)
		//	right=SelectConstaintExpression)?;
		public ParserRule getRule() { return rule; }

		//BasicSelectConstraint (=> ({SelectConstaintExpression.left=current} operator=LogicOperator)
		//right=SelectConstaintExpression)?
		public Group getGroup() { return cGroup; }

		//BasicSelectConstraint
		public RuleCall getBasicSelectConstraintParserRuleCall_0() { return cBasicSelectConstraintParserRuleCall_0; }

		//(=> ({SelectConstaintExpression.left=current} operator=LogicOperator) right=SelectConstaintExpression)?
		public Group getGroup_1() { return cGroup_1; }

		//=> ({SelectConstaintExpression.left=current} operator=LogicOperator)
		public Group getGroup_1_0() { return cGroup_1_0; }

		//{SelectConstaintExpression.left=current} operator=LogicOperator
		public Group getGroup_1_0_0() { return cGroup_1_0_0; }

		//{SelectConstaintExpression.left=current}
		public Action getSelectConstaintExpressionLeftAction_1_0_0_0() { return cSelectConstaintExpressionLeftAction_1_0_0_0; }

		//operator=LogicOperator
		public Assignment getOperatorAssignment_1_0_0_1() { return cOperatorAssignment_1_0_0_1; }

		//LogicOperator
		public RuleCall getOperatorLogicOperatorEnumRuleCall_1_0_0_1_0() { return cOperatorLogicOperatorEnumRuleCall_1_0_0_1_0; }

		//right=SelectConstaintExpression
		public Assignment getRightAssignment_1_1() { return cRightAssignment_1_1; }

		//SelectConstaintExpression
		public RuleCall getRightSelectConstaintExpressionParserRuleCall_1_1_0() { return cRightSelectConstaintExpressionParserRuleCall_1_1_0; }
	}

	public class BasicSelectConstraintElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BasicSelectConstraint");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cParenthesisSelectConstraintParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cSelectConstraintParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//BasicSelectConstraint returns SelectConstaintExpression:
		//	ParenthesisSelectConstraint | SelectConstraint;
		public ParserRule getRule() { return rule; }

		//ParenthesisSelectConstraint | SelectConstraint
		public Alternatives getAlternatives() { return cAlternatives; }

		//ParenthesisSelectConstraint
		public RuleCall getParenthesisSelectConstraintParserRuleCall_0() { return cParenthesisSelectConstraintParserRuleCall_0; }

		//SelectConstraint
		public RuleCall getSelectConstraintParserRuleCall_1() { return cSelectConstraintParserRuleCall_1; }
	}

	public class ParenthesisSelectConstraintElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ParenthesisSelectConstraint");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cConstraintAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cConstraintSelectConstaintExpressionParserRuleCall_1_0 = (RuleCall)cConstraintAssignment_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//ParenthesisSelectConstraint returns SelectConstaintExpression:
		//	"(" constraint=SelectConstaintExpression ")";
		public ParserRule getRule() { return rule; }

		//"(" constraint=SelectConstaintExpression ")"
		public Group getGroup() { return cGroup; }

		//"("
		public Keyword getLeftParenthesisKeyword_0() { return cLeftParenthesisKeyword_0; }

		//constraint=SelectConstaintExpression
		public Assignment getConstraintAssignment_1() { return cConstraintAssignment_1; }

		//SelectConstaintExpression
		public RuleCall getConstraintSelectConstaintExpressionParserRuleCall_1_0() { return cConstraintSelectConstaintExpressionParserRuleCall_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_2() { return cRightParenthesisKeyword_2; }
	}

	public class SelectConstraintElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SelectConstraint");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cLeftAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cLeftCompareOperandParserRuleCall_0_0 = (RuleCall)cLeftAssignment_0.eContents().get(0);
		private final Assignment cComperatorAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cComperatorComparatorEnumRuleCall_1_0 = (RuleCall)cComperatorAssignment_1.eContents().get(0);
		private final Assignment cRightAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cRightCompareOperandParserRuleCall_2_0 = (RuleCall)cRightAssignment_2.eContents().get(0);
		
		//SelectConstraint returns SelectConstaintExpression:
		//	left=CompareOperand comperator=Comparator right=CompareOperand;
		public ParserRule getRule() { return rule; }

		//left=CompareOperand comperator=Comparator right=CompareOperand
		public Group getGroup() { return cGroup; }

		//left=CompareOperand
		public Assignment getLeftAssignment_0() { return cLeftAssignment_0; }

		//CompareOperand
		public RuleCall getLeftCompareOperandParserRuleCall_0_0() { return cLeftCompareOperandParserRuleCall_0_0; }

		//comperator=Comparator
		public Assignment getComperatorAssignment_1() { return cComperatorAssignment_1; }

		//Comparator
		public RuleCall getComperatorComparatorEnumRuleCall_1_0() { return cComperatorComparatorEnumRuleCall_1_0; }

		//right=CompareOperand
		public Assignment getRightAssignment_2() { return cRightAssignment_2; }

		//CompareOperand
		public RuleCall getRightCompareOperandParserRuleCall_2_0() { return cRightCompareOperandParserRuleCall_2_0; }
	}

	public class CompareOperandElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "CompareOperand");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cParameterExpressionParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cLiteralParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//CompareOperand:
		//	ParameterExpression | Literal;
		public ParserRule getRule() { return rule; }

		//ParameterExpression | Literal
		public Alternatives getAlternatives() { return cAlternatives; }

		//ParameterExpression
		public RuleCall getParameterExpressionParserRuleCall_0() { return cParameterExpressionParserRuleCall_0; }

		//Literal
		public RuleCall getLiteralParserRuleCall_1() { return cLiteralParserRuleCall_1; }
	}

	public class ParameterExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ParameterExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cGroup.eContents().get(0);
		private final Assignment cInputAssignment_0_0 = (Assignment)cGroup_0.eContents().get(0);
		private final CrossReference cInputSelectInputCrossReference_0_0_0 = (CrossReference)cInputAssignment_0_0.eContents().get(0);
		private final RuleCall cInputSelectInputIDTerminalRuleCall_0_0_0_1 = (RuleCall)cInputSelectInputCrossReference_0_0_0.eContents().get(1);
		private final Keyword cFullStopKeyword_0_1 = (Keyword)cGroup_0.eContents().get(1);
		private final Assignment cPropertyReferenceAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final CrossReference cPropertyReferencePropertyCrossReference_1_0 = (CrossReference)cPropertyReferenceAssignment_1.eContents().get(0);
		private final RuleCall cPropertyReferencePropertyIDTerminalRuleCall_1_0_1 = (RuleCall)cPropertyReferencePropertyCrossReference_1_0.eContents().get(1);
		
		//ParameterExpression:
		//	(input=[SelectInput] ".")? propertyReference=[record::Property];
		public ParserRule getRule() { return rule; }

		//(input=[SelectInput] ".")? propertyReference=[record::Property]
		public Group getGroup() { return cGroup; }

		//(input=[SelectInput] ".")?
		public Group getGroup_0() { return cGroup_0; }

		//input=[SelectInput]
		public Assignment getInputAssignment_0_0() { return cInputAssignment_0_0; }

		//[SelectInput]
		public CrossReference getInputSelectInputCrossReference_0_0_0() { return cInputSelectInputCrossReference_0_0_0; }

		//ID
		public RuleCall getInputSelectInputIDTerminalRuleCall_0_0_0_1() { return cInputSelectInputIDTerminalRuleCall_0_0_0_1; }

		//"."
		public Keyword getFullStopKeyword_0_1() { return cFullStopKeyword_0_1; }

		//propertyReference=[record::Property]
		public Assignment getPropertyReferenceAssignment_1() { return cPropertyReferenceAssignment_1; }

		//[record::Property]
		public CrossReference getPropertyReferencePropertyCrossReference_1_0() { return cPropertyReferencePropertyCrossReference_1_0; }

		//ID
		public RuleCall getPropertyReferencePropertyIDTerminalRuleCall_1_0_1() { return cPropertyReferencePropertyIDTerminalRuleCall_1_0_1; }
	}

	public class FilterElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Filter");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cFilterKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Assignment cSourceReferenceAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cSourceReferenceSourceReferenceParserRuleCall_2_0 = (RuleCall)cSourceReferenceAssignment_2.eContents().get(0);
		private final Assignment cConstraintAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cConstraintConstraintExpressionParserRuleCall_3_0 = (RuleCall)cConstraintAssignment_3.eContents().get(0);
		
		//// ------------------------
		//// filter
		//Filter:
		//	"filter" name=ID sourceReference=SourceReference constraint=ConstraintExpression;
		public ParserRule getRule() { return rule; }

		//"filter" name=ID sourceReference=SourceReference constraint=ConstraintExpression
		public Group getGroup() { return cGroup; }

		//"filter"
		public Keyword getFilterKeyword_0() { return cFilterKeyword_0; }

		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }

		//sourceReference=SourceReference
		public Assignment getSourceReferenceAssignment_2() { return cSourceReferenceAssignment_2; }

		//SourceReference
		public RuleCall getSourceReferenceSourceReferenceParserRuleCall_2_0() { return cSourceReferenceSourceReferenceParserRuleCall_2_0; }

		//constraint=ConstraintExpression
		public Assignment getConstraintAssignment_3() { return cConstraintAssignment_3; }

		//ConstraintExpression
		public RuleCall getConstraintConstraintExpressionParserRuleCall_3_0() { return cConstraintConstraintExpressionParserRuleCall_3_0; }
	}

	public class ConstraintExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ConstraintExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cBasicConstraintParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cGroup_1.eContents().get(0);
		private final Group cGroup_1_0_0 = (Group)cGroup_1_0.eContents().get(0);
		private final Action cConstraintExpressionLeftAction_1_0_0_0 = (Action)cGroup_1_0_0.eContents().get(0);
		private final Assignment cOperatorAssignment_1_0_0_1 = (Assignment)cGroup_1_0_0.eContents().get(1);
		private final RuleCall cOperatorLogicOperatorEnumRuleCall_1_0_0_1_0 = (RuleCall)cOperatorAssignment_1_0_0_1.eContents().get(0);
		private final Assignment cRightAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cRightPropertyConstraintParserRuleCall_1_1_0 = (RuleCall)cRightAssignment_1_1.eContents().get(0);
		
		//ConstraintExpression:
		//	BasicConstraint (=> ({ConstraintExpression.left=current} operator=LogicOperator) right=PropertyConstraint)?;
		public ParserRule getRule() { return rule; }

		//BasicConstraint (=> ({ConstraintExpression.left=current} operator=LogicOperator) right=PropertyConstraint)?
		public Group getGroup() { return cGroup; }

		//BasicConstraint
		public RuleCall getBasicConstraintParserRuleCall_0() { return cBasicConstraintParserRuleCall_0; }

		//(=> ({ConstraintExpression.left=current} operator=LogicOperator) right=PropertyConstraint)?
		public Group getGroup_1() { return cGroup_1; }

		//=> ({ConstraintExpression.left=current} operator=LogicOperator)
		public Group getGroup_1_0() { return cGroup_1_0; }

		//{ConstraintExpression.left=current} operator=LogicOperator
		public Group getGroup_1_0_0() { return cGroup_1_0_0; }

		//{ConstraintExpression.left=current}
		public Action getConstraintExpressionLeftAction_1_0_0_0() { return cConstraintExpressionLeftAction_1_0_0_0; }

		//operator=LogicOperator
		public Assignment getOperatorAssignment_1_0_0_1() { return cOperatorAssignment_1_0_0_1; }

		//LogicOperator
		public RuleCall getOperatorLogicOperatorEnumRuleCall_1_0_0_1_0() { return cOperatorLogicOperatorEnumRuleCall_1_0_0_1_0; }

		//right=PropertyConstraint
		public Assignment getRightAssignment_1_1() { return cRightAssignment_1_1; }

		//PropertyConstraint
		public RuleCall getRightPropertyConstraintParserRuleCall_1_1_0() { return cRightPropertyConstraintParserRuleCall_1_1_0; }
	}

	public class BasicConstraintElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BasicConstraint");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cParenthesisConstraintParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cConstraintParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//BasicConstraint returns ConstraintExpression:
		//	ParenthesisConstraint | Constraint;
		public ParserRule getRule() { return rule; }

		//ParenthesisConstraint | Constraint
		public Alternatives getAlternatives() { return cAlternatives; }

		//ParenthesisConstraint
		public RuleCall getParenthesisConstraintParserRuleCall_0() { return cParenthesisConstraintParserRuleCall_0; }

		//Constraint
		public RuleCall getConstraintParserRuleCall_1() { return cConstraintParserRuleCall_1; }
	}

	public class ParenthesisConstraintElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ParenthesisConstraint");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cConstraintAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cConstraintConstraintExpressionParserRuleCall_1_0 = (RuleCall)cConstraintAssignment_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//ParenthesisConstraint returns ConstraintExpression:
		//	"(" constraint=ConstraintExpression ")";
		public ParserRule getRule() { return rule; }

		//"(" constraint=ConstraintExpression ")"
		public Group getGroup() { return cGroup; }

		//"("
		public Keyword getLeftParenthesisKeyword_0() { return cLeftParenthesisKeyword_0; }

		//constraint=ConstraintExpression
		public Assignment getConstraintAssignment_1() { return cConstraintAssignment_1; }

		//ConstraintExpression
		public RuleCall getConstraintConstraintExpressionParserRuleCall_1_0() { return cConstraintConstraintExpressionParserRuleCall_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_2() { return cRightParenthesisKeyword_2; }
	}

	public class ConstraintElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Constraint");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cTypeSelectionAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cTypeSelectionTypeSelectionParserRuleCall_0_0 = (RuleCall)cTypeSelectionAssignment_0.eContents().get(0);
		private final Assignment cPropertyConstraintAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cPropertyConstraintPropertyConstraintParserRuleCall_1_0 = (RuleCall)cPropertyConstraintAssignment_1.eContents().get(0);
		
		//Constraint returns ConstraintExpression:
		//	typeSelection=TypeSelection propertyConstraint=PropertyConstraint?;
		public ParserRule getRule() { return rule; }

		//typeSelection=TypeSelection propertyConstraint=PropertyConstraint?
		public Group getGroup() { return cGroup; }

		//typeSelection=TypeSelection
		public Assignment getTypeSelectionAssignment_0() { return cTypeSelectionAssignment_0; }

		//TypeSelection
		public RuleCall getTypeSelectionTypeSelectionParserRuleCall_0_0() { return cTypeSelectionTypeSelectionParserRuleCall_0_0; }

		//propertyConstraint=PropertyConstraint?
		public Assignment getPropertyConstraintAssignment_1() { return cPropertyConstraintAssignment_1; }

		//PropertyConstraint
		public RuleCall getPropertyConstraintPropertyConstraintParserRuleCall_1_0() { return cPropertyConstraintPropertyConstraintParserRuleCall_1_0; }
	}

	public class PropertyConstraintElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PropertyConstraint");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cBasicPropertyConstraintParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cGroup_1.eContents().get(0);
		private final Group cGroup_1_0_0 = (Group)cGroup_1_0.eContents().get(0);
		private final Action cPropertyConstraintLeftAction_1_0_0_0 = (Action)cGroup_1_0_0.eContents().get(0);
		private final Assignment cOperatorAssignment_1_0_0_1 = (Assignment)cGroup_1_0_0.eContents().get(1);
		private final RuleCall cOperatorLogicOperatorEnumRuleCall_1_0_0_1_0 = (RuleCall)cOperatorAssignment_1_0_0_1.eContents().get(0);
		private final Assignment cRightAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cRightPropertyConstraintParserRuleCall_1_1_0 = (RuleCall)cRightAssignment_1_1.eContents().get(0);
		
		//PropertyConstraint:
		//	BasicPropertyConstraint (=> ({PropertyConstraint.left=current} operator=LogicOperator) right=PropertyConstraint)?;
		public ParserRule getRule() { return rule; }

		//BasicPropertyConstraint (=> ({PropertyConstraint.left=current} operator=LogicOperator) right=PropertyConstraint)?
		public Group getGroup() { return cGroup; }

		//BasicPropertyConstraint
		public RuleCall getBasicPropertyConstraintParserRuleCall_0() { return cBasicPropertyConstraintParserRuleCall_0; }

		//(=> ({PropertyConstraint.left=current} operator=LogicOperator) right=PropertyConstraint)?
		public Group getGroup_1() { return cGroup_1; }

		//=> ({PropertyConstraint.left=current} operator=LogicOperator)
		public Group getGroup_1_0() { return cGroup_1_0; }

		//{PropertyConstraint.left=current} operator=LogicOperator
		public Group getGroup_1_0_0() { return cGroup_1_0_0; }

		//{PropertyConstraint.left=current}
		public Action getPropertyConstraintLeftAction_1_0_0_0() { return cPropertyConstraintLeftAction_1_0_0_0; }

		//operator=LogicOperator
		public Assignment getOperatorAssignment_1_0_0_1() { return cOperatorAssignment_1_0_0_1; }

		//LogicOperator
		public RuleCall getOperatorLogicOperatorEnumRuleCall_1_0_0_1_0() { return cOperatorLogicOperatorEnumRuleCall_1_0_0_1_0; }

		//right=PropertyConstraint
		public Assignment getRightAssignment_1_1() { return cRightAssignment_1_1; }

		//PropertyConstraint
		public RuleCall getRightPropertyConstraintParserRuleCall_1_1_0() { return cRightPropertyConstraintParserRuleCall_1_1_0; }
	}

	public class BasicPropertyConstraintElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BasicPropertyConstraint");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cPropertyParenthesisConstraintParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cPropertyValueConstraintParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//BasicPropertyConstraint returns PropertyConstraint:
		//	PropertyParenthesisConstraint | PropertyValueConstraint;
		public ParserRule getRule() { return rule; }

		//PropertyParenthesisConstraint | PropertyValueConstraint
		public Alternatives getAlternatives() { return cAlternatives; }

		//PropertyParenthesisConstraint
		public RuleCall getPropertyParenthesisConstraintParserRuleCall_0() { return cPropertyParenthesisConstraintParserRuleCall_0; }

		//PropertyValueConstraint
		public RuleCall getPropertyValueConstraintParserRuleCall_1() { return cPropertyValueConstraintParserRuleCall_1; }
	}

	public class PropertyParenthesisConstraintElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PropertyParenthesisConstraint");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cConstraintAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cConstraintPropertyConstraintParserRuleCall_1_0 = (RuleCall)cConstraintAssignment_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//PropertyParenthesisConstraint returns PropertyConstraint:
		//	"(" constraint=PropertyConstraint ")";
		public ParserRule getRule() { return rule; }

		//"(" constraint=PropertyConstraint ")"
		public Group getGroup() { return cGroup; }

		//"("
		public Keyword getLeftParenthesisKeyword_0() { return cLeftParenthesisKeyword_0; }

		//constraint=PropertyConstraint
		public Assignment getConstraintAssignment_1() { return cConstraintAssignment_1; }

		//PropertyConstraint
		public RuleCall getConstraintPropertyConstraintParserRuleCall_1_0() { return cConstraintPropertyConstraintParserRuleCall_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_2() { return cRightParenthesisKeyword_2; }
	}

	public class PropertyValueConstraintElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PropertyValueConstraint");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cPropertyAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cPropertyPropertyCrossReference_0_0 = (CrossReference)cPropertyAssignment_0.eContents().get(0);
		private final RuleCall cPropertyPropertyIDTerminalRuleCall_0_0_1 = (RuleCall)cPropertyPropertyCrossReference_0_0.eContents().get(1);
		private final Assignment cComparatorAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cComparatorComparatorEnumRuleCall_1_0 = (RuleCall)cComparatorAssignment_1.eContents().get(0);
		private final Assignment cValueAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cValueLiteralParserRuleCall_2_0 = (RuleCall)cValueAssignment_2.eContents().get(0);
		
		//PropertyValueConstraint returns PropertyConstraint:
		//	property=[record::Property] comparator=Comparator value=Literal;
		public ParserRule getRule() { return rule; }

		//property=[record::Property] comparator=Comparator value=Literal
		public Group getGroup() { return cGroup; }

		//property=[record::Property]
		public Assignment getPropertyAssignment_0() { return cPropertyAssignment_0; }

		//[record::Property]
		public CrossReference getPropertyPropertyCrossReference_0_0() { return cPropertyPropertyCrossReference_0_0; }

		//ID
		public RuleCall getPropertyPropertyIDTerminalRuleCall_0_0_1() { return cPropertyPropertyIDTerminalRuleCall_0_0_1; }

		//comparator=Comparator
		public Assignment getComparatorAssignment_1() { return cComparatorAssignment_1; }

		//Comparator
		public RuleCall getComparatorComparatorEnumRuleCall_1_0() { return cComparatorComparatorEnumRuleCall_1_0; }

		//value=Literal
		public Assignment getValueAssignment_2() { return cValueAssignment_2; }

		//Literal
		public RuleCall getValueLiteralParserRuleCall_2_0() { return cValueLiteralParserRuleCall_2_0; }
	}

	public class TypeSelectionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TypeSelection");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cConcreteTypeParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cTemplateTypeSelectionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cRecordTypeSelectionParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//TypeSelection:
		//	ConcreteType | TemplateTypeSelection | RecordTypeSelection;
		public ParserRule getRule() { return rule; }

		//ConcreteType | TemplateTypeSelection | RecordTypeSelection
		public Alternatives getAlternatives() { return cAlternatives; }

		//ConcreteType
		public RuleCall getConcreteTypeParserRuleCall_0() { return cConcreteTypeParserRuleCall_0; }

		//TemplateTypeSelection
		public RuleCall getTemplateTypeSelectionParserRuleCall_1() { return cTemplateTypeSelectionParserRuleCall_1; }

		//RecordTypeSelection
		public RuleCall getRecordTypeSelectionParserRuleCall_2() { return cRecordTypeSelectionParserRuleCall_2; }
	}

	public class ConcreteTypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ConcreteType");
		private final Assignment cTypeAssignment = (Assignment)rule.eContents().get(1);
		private final CrossReference cTypeTypeCrossReference_0 = (CrossReference)cTypeAssignment.eContents().get(0);
		private final RuleCall cTypeTypeIDTerminalRuleCall_0_1 = (RuleCall)cTypeTypeCrossReference_0.eContents().get(1);
		
		//ConcreteType:
		//	type=[record::Type];
		public ParserRule getRule() { return rule; }

		//type=[record::Type]
		public Assignment getTypeAssignment() { return cTypeAssignment; }

		//[record::Type]
		public CrossReference getTypeTypeCrossReference_0() { return cTypeTypeCrossReference_0; }

		//ID
		public RuleCall getTypeTypeIDTerminalRuleCall_0_1() { return cTypeTypeIDTerminalRuleCall_0_1; }
	}

	public class TemplateTypeSelectionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TemplateTypeSelection");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cQuestionMarkKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cUsesKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cTypesAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final CrossReference cTypesTemplateTypeCrossReference_2_0 = (CrossReference)cTypesAssignment_2.eContents().get(0);
		private final RuleCall cTypesTemplateTypeIDTerminalRuleCall_2_0_1 = (RuleCall)cTypesTemplateTypeCrossReference_2_0.eContents().get(1);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cCommaKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Assignment cTypesAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final CrossReference cTypesTemplateTypeCrossReference_3_1_0 = (CrossReference)cTypesAssignment_3_1.eContents().get(0);
		private final RuleCall cTypesTemplateTypeQualifiedNameParserRuleCall_3_1_0_1 = (RuleCall)cTypesTemplateTypeCrossReference_3_1_0.eContents().get(1);
		
		//TemplateTypeSelection:
		//	"?" "uses" types+=[record::TemplateType] ("," types+=[record::TemplateType|QualifiedName])*;
		public ParserRule getRule() { return rule; }

		//"?" "uses" types+=[record::TemplateType] ("," types+=[record::TemplateType|QualifiedName])*
		public Group getGroup() { return cGroup; }

		//"?"
		public Keyword getQuestionMarkKeyword_0() { return cQuestionMarkKeyword_0; }

		//"uses"
		public Keyword getUsesKeyword_1() { return cUsesKeyword_1; }

		//types+=[record::TemplateType]
		public Assignment getTypesAssignment_2() { return cTypesAssignment_2; }

		//[record::TemplateType]
		public CrossReference getTypesTemplateTypeCrossReference_2_0() { return cTypesTemplateTypeCrossReference_2_0; }

		//ID
		public RuleCall getTypesTemplateTypeIDTerminalRuleCall_2_0_1() { return cTypesTemplateTypeIDTerminalRuleCall_2_0_1; }

		//("," types+=[record::TemplateType|QualifiedName])*
		public Group getGroup_3() { return cGroup_3; }

		//","
		public Keyword getCommaKeyword_3_0() { return cCommaKeyword_3_0; }

		//types+=[record::TemplateType|QualifiedName]
		public Assignment getTypesAssignment_3_1() { return cTypesAssignment_3_1; }

		//[record::TemplateType|QualifiedName]
		public CrossReference getTypesTemplateTypeCrossReference_3_1_0() { return cTypesTemplateTypeCrossReference_3_1_0; }

		//QualifiedName
		public RuleCall getTypesTemplateTypeQualifiedNameParserRuleCall_3_1_0_1() { return cTypesTemplateTypeQualifiedNameParserRuleCall_3_1_0_1; }
	}

	public class RecordTypeSelectionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "RecordTypeSelection");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cQuestionMarkKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cModifierAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cModifierRecordTypeModifierEnumRuleCall_1_0 = (RuleCall)cModifierAssignment_1.eContents().get(0);
		private final Assignment cTypeAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final CrossReference cTypeRecordTypeCrossReference_2_0 = (CrossReference)cTypeAssignment_2.eContents().get(0);
		private final RuleCall cTypeRecordTypeIDTerminalRuleCall_2_0_1 = (RuleCall)cTypeRecordTypeCrossReference_2_0.eContents().get(1);
		
		//RecordTypeSelection:
		//	"?" modifier=RecordTypeModifier type=[record::RecordType];
		public ParserRule getRule() { return rule; }

		//"?" modifier=RecordTypeModifier type=[record::RecordType]
		public Group getGroup() { return cGroup; }

		//"?"
		public Keyword getQuestionMarkKeyword_0() { return cQuestionMarkKeyword_0; }

		//modifier=RecordTypeModifier
		public Assignment getModifierAssignment_1() { return cModifierAssignment_1; }

		//RecordTypeModifier
		public RuleCall getModifierRecordTypeModifierEnumRuleCall_1_0() { return cModifierRecordTypeModifierEnumRuleCall_1_0; }

		//type=[record::RecordType]
		public Assignment getTypeAssignment_2() { return cTypeAssignment_2; }

		//[record::RecordType]
		public CrossReference getTypeRecordTypeCrossReference_2_0() { return cTypeRecordTypeCrossReference_2_0; }

		//ID
		public RuleCall getTypeRecordTypeIDTerminalRuleCall_2_0_1() { return cTypeRecordTypeIDTerminalRuleCall_2_0_1; }
	}

	public class SourceReferenceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SourceReference");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cFromKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Assignment cFilterAssignment_1_0 = (Assignment)cAlternatives_1.eContents().get(0);
		private final CrossReference cFilterOperationCrossReference_1_0_0 = (CrossReference)cFilterAssignment_1_0.eContents().get(0);
		private final RuleCall cFilterOperationIDTerminalRuleCall_1_0_0_1 = (RuleCall)cFilterOperationCrossReference_1_0_0.eContents().get(1);
		private final Assignment cDefaultAssignment_1_1 = (Assignment)cAlternatives_1.eContents().get(1);
		private final Keyword cDefaultDefaultKeyword_1_1_0 = (Keyword)cDefaultAssignment_1_1.eContents().get(0);
		
		//// -----------------------------------
		//// Common rules
		//SourceReference:
		//	"from" (filter=[Operation] | default?="default");
		public ParserRule getRule() { return rule; }

		//"from" (filter=[Operation] | default?="default")
		public Group getGroup() { return cGroup; }

		//"from"
		public Keyword getFromKeyword_0() { return cFromKeyword_0; }

		//filter=[Operation] | default?="default"
		public Alternatives getAlternatives_1() { return cAlternatives_1; }

		//filter=[Operation]
		public Assignment getFilterAssignment_1_0() { return cFilterAssignment_1_0; }

		//[Operation]
		public CrossReference getFilterOperationCrossReference_1_0_0() { return cFilterOperationCrossReference_1_0_0; }

		//ID
		public RuleCall getFilterOperationIDTerminalRuleCall_1_0_0_1() { return cFilterOperationIDTerminalRuleCall_1_0_0_1; }

		//default?="default"
		public Assignment getDefaultAssignment_1_1() { return cDefaultAssignment_1_1; }

		//"default"
		public Keyword getDefaultDefaultKeyword_1_1_0() { return cDefaultDefaultKeyword_1_1_0; }
	}

	public class LiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Literal");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cStringLiteralParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cIntLiteralParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cFloatLiteralParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cBooleanLiteralParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cArrayLiteralParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		private final RuleCall cBuiltInValueLiteralParserRuleCall_5 = (RuleCall)cAlternatives.eContents().get(5);
		
		//// TODO we might replace default by a distinct selection of different inputs
		//// -----------------------------------
		//// Literal
		//Literal:
		//	StringLiteral | IntLiteral | FloatLiteral | BooleanLiteral | ArrayLiteral | BuiltInValueLiteral;
		public ParserRule getRule() { return rule; }

		//StringLiteral | IntLiteral | FloatLiteral | BooleanLiteral | ArrayLiteral | BuiltInValueLiteral
		public Alternatives getAlternatives() { return cAlternatives; }

		//StringLiteral
		public RuleCall getStringLiteralParserRuleCall_0() { return cStringLiteralParserRuleCall_0; }

		//IntLiteral
		public RuleCall getIntLiteralParserRuleCall_1() { return cIntLiteralParserRuleCall_1; }

		//FloatLiteral
		public RuleCall getFloatLiteralParserRuleCall_2() { return cFloatLiteralParserRuleCall_2; }

		//BooleanLiteral
		public RuleCall getBooleanLiteralParserRuleCall_3() { return cBooleanLiteralParserRuleCall_3; }

		//ArrayLiteral
		public RuleCall getArrayLiteralParserRuleCall_4() { return cArrayLiteralParserRuleCall_4; }

		//BuiltInValueLiteral
		public RuleCall getBuiltInValueLiteralParserRuleCall_5() { return cBuiltInValueLiteralParserRuleCall_5; }
	}

	public class ArrayLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ArrayLiteral");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftCurlyBracketKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cLiteralsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cLiteralsLiteralParserRuleCall_1_0 = (RuleCall)cLiteralsAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cCommaKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cLiteralsAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cLiteralsLiteralParserRuleCall_2_1_0 = (RuleCall)cLiteralsAssignment_2_1.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//ArrayLiteral:
		//	"{" literals+=Literal ("," literals+=Literal)* "}";
		public ParserRule getRule() { return rule; }

		//"{" literals+=Literal ("," literals+=Literal)* "}"
		public Group getGroup() { return cGroup; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_0() { return cLeftCurlyBracketKeyword_0; }

		//literals+=Literal
		public Assignment getLiteralsAssignment_1() { return cLiteralsAssignment_1; }

		//Literal
		public RuleCall getLiteralsLiteralParserRuleCall_1_0() { return cLiteralsLiteralParserRuleCall_1_0; }

		//("," literals+=Literal)*
		public Group getGroup_2() { return cGroup_2; }

		//","
		public Keyword getCommaKeyword_2_0() { return cCommaKeyword_2_0; }

		//literals+=Literal
		public Assignment getLiteralsAssignment_2_1() { return cLiteralsAssignment_2_1; }

		//Literal
		public RuleCall getLiteralsLiteralParserRuleCall_2_1_0() { return cLiteralsLiteralParserRuleCall_2_1_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_3() { return cRightCurlyBracketKeyword_3; }
	}

	public class StringLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "StringLiteral");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueSTRINGTerminalRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//StringLiteral:
		//	value=STRING;
		public ParserRule getRule() { return rule; }

		//value=STRING
		public Assignment getValueAssignment() { return cValueAssignment; }

		//STRING
		public RuleCall getValueSTRINGTerminalRuleCall_0() { return cValueSTRINGTerminalRuleCall_0; }
	}

	public class IntLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "IntLiteral");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueINTTerminalRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//IntLiteral:
		//	value=INT;
		public ParserRule getRule() { return rule; }

		//value=INT
		public Assignment getValueAssignment() { return cValueAssignment; }

		//INT
		public RuleCall getValueINTTerminalRuleCall_0() { return cValueINTTerminalRuleCall_0; }
	}

	public class FloatLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "FloatLiteral");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueFLOATTerminalRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//FloatLiteral:
		//	value=FLOAT;
		public ParserRule getRule() { return rule; }

		//value=FLOAT
		public Assignment getValueAssignment() { return cValueAssignment; }

		//FLOAT
		public RuleCall getValueFLOATTerminalRuleCall_0() { return cValueFLOATTerminalRuleCall_0; }
	}

	public class BooleanLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BooleanLiteral");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueBOOLEANTerminalRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//BooleanLiteral:
		//	value=BOOLEAN;
		public ParserRule getRule() { return rule; }

		//value=BOOLEAN
		public Assignment getValueAssignment() { return cValueAssignment; }

		//BOOLEAN
		public RuleCall getValueBOOLEANTerminalRuleCall_0() { return cValueBOOLEANTerminalRuleCall_0; }
	}

	public class BuiltInValueLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BuiltInValueLiteral");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBuiltInValueLiteralAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cValueAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Keyword cValueKIEKER_VERSIONKeyword_1_0 = (Keyword)cValueAssignment_1.eContents().get(0);
		
		//BuiltInValueLiteral:
		//	{BuiltInValueLiteral} value="KIEKER_VERSION";
		public ParserRule getRule() { return rule; }

		//{BuiltInValueLiteral} value="KIEKER_VERSION"
		public Group getGroup() { return cGroup; }

		//{BuiltInValueLiteral}
		public Action getBuiltInValueLiteralAction_0() { return cBuiltInValueLiteralAction_0; }

		//value="KIEKER_VERSION"
		public Assignment getValueAssignment_1() { return cValueAssignment_1; }

		//"KIEKER_VERSION"
		public Keyword getValueKIEKER_VERSIONKeyword_1_0() { return cValueKIEKER_VERSIONKeyword_1_0; }
	}

	public class QualifiedNameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "QualifiedName");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cIDTerminalRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cFullStopKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final RuleCall cIDTerminalRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		
		//QualifiedName:
		//	ID ("." ID)*;
		public ParserRule getRule() { return rule; }

		//ID ("." ID)*
		public Group getGroup() { return cGroup; }

		//ID
		public RuleCall getIDTerminalRuleCall_0() { return cIDTerminalRuleCall_0; }

		//(=> "." ID)*
		public Group getGroup_1() { return cGroup_1; }

		//=> "."
		public Keyword getFullStopKeyword_1_0() { return cFullStopKeyword_1_0; }

		//ID
		public RuleCall getIDTerminalRuleCall_1_1() { return cIDTerminalRuleCall_1_1; }
	}

	public class QualifiedNameWithWildcardElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "QualifiedNameWithWildcard");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cQualifiedNameParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cFullStopKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Keyword cAsteriskKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		
		//QualifiedNameWithWildcard:
		//	QualifiedName ("." "*")?;
		public ParserRule getRule() { return rule; }

		//QualifiedName ("." "*")?
		public Group getGroup() { return cGroup; }

		//QualifiedName
		public RuleCall getQualifiedNameParserRuleCall_0() { return cQualifiedNameParserRuleCall_0; }

		//("." "*")?
		public Group getGroup_1() { return cGroup_1; }

		//"."
		public Keyword getFullStopKeyword_1_0() { return cFullStopKeyword_1_0; }

		//"*"
		public Keyword getAsteriskKeyword_1_1() { return cAsteriskKeyword_1_1; }
	}
	
	
	public class RecordTypeModifierElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "RecordTypeModifier");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cSUPEREnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cSUPERSuperKeyword_0_0 = (Keyword)cSUPEREnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cEXTENDSEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cEXTENDSExtendsKeyword_1_0 = (Keyword)cEXTENDSEnumLiteralDeclaration_1.eContents().get(0);
		
		//enum RecordTypeModifier:
		//	SUPER="super" | EXTENDS="extends";
		public EnumRule getRule() { return rule; }

		//SUPER="super" | EXTENDS="extends"
		public Alternatives getAlternatives() { return cAlternatives; }

		//SUPER="super"
		public EnumLiteralDeclaration getSUPEREnumLiteralDeclaration_0() { return cSUPEREnumLiteralDeclaration_0; }

		//"super"
		public Keyword getSUPERSuperKeyword_0_0() { return cSUPERSuperKeyword_0_0; }

		//EXTENDS="extends"
		public EnumLiteralDeclaration getEXTENDSEnumLiteralDeclaration_1() { return cEXTENDSEnumLiteralDeclaration_1; }

		//"extends"
		public Keyword getEXTENDSExtendsKeyword_1_0() { return cEXTENDSExtendsKeyword_1_0; }
	}

	public class LogicOperatorElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "LogicOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cANDEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cANDAmpersandKeyword_0_0 = (Keyword)cANDEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cOREnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cORVerticalLineKeyword_1_0 = (Keyword)cOREnumLiteralDeclaration_1.eContents().get(0);
		
		//// -----------------------------------
		//// Terminals
		//enum LogicOperator:
		//	AND="&" | OR="|";
		public EnumRule getRule() { return rule; }

		//AND="&" | OR="|"
		public Alternatives getAlternatives() { return cAlternatives; }

		//AND="&"
		public EnumLiteralDeclaration getANDEnumLiteralDeclaration_0() { return cANDEnumLiteralDeclaration_0; }

		//"&"
		public Keyword getANDAmpersandKeyword_0_0() { return cANDAmpersandKeyword_0_0; }

		//OR="|"
		public EnumLiteralDeclaration getOREnumLiteralDeclaration_1() { return cOREnumLiteralDeclaration_1; }

		//"|"
		public Keyword getORVerticalLineKeyword_1_0() { return cORVerticalLineKeyword_1_0; }
	}

	public class ComparatorElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "Comparator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cEQEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cEQEqualsSignEqualsSignKeyword_0_0 = (Keyword)cEQEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cNEEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cNEExclamationMarkEqualsSignKeyword_1_0 = (Keyword)cNEEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cGREnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cGRGreaterThanSignKeyword_2_0 = (Keyword)cGREnumLiteralDeclaration_2.eContents().get(0);
		private final EnumLiteralDeclaration cLWEnumLiteralDeclaration_3 = (EnumLiteralDeclaration)cAlternatives.eContents().get(3);
		private final Keyword cLWLessThanSignKeyword_3_0 = (Keyword)cLWEnumLiteralDeclaration_3.eContents().get(0);
		private final EnumLiteralDeclaration cGEEnumLiteralDeclaration_4 = (EnumLiteralDeclaration)cAlternatives.eContents().get(4);
		private final Keyword cGEGreaterThanSignEqualsSignKeyword_4_0 = (Keyword)cGEEnumLiteralDeclaration_4.eContents().get(0);
		private final EnumLiteralDeclaration cLEEnumLiteralDeclaration_5 = (EnumLiteralDeclaration)cAlternatives.eContents().get(5);
		private final Keyword cLELessThanSignEqualsSignKeyword_5_0 = (Keyword)cLEEnumLiteralDeclaration_5.eContents().get(0);
		private final EnumLiteralDeclaration cLIKEEnumLiteralDeclaration_6 = (EnumLiteralDeclaration)cAlternatives.eContents().get(6);
		private final Keyword cLIKETildeKeyword_6_0 = (Keyword)cLIKEEnumLiteralDeclaration_6.eContents().get(0);
		
		//enum Comparator:
		//	EQ="==" | NE="!=" | GR=">" | LW="<" | GE=">=" | LE="<=" | LIKE="~";
		public EnumRule getRule() { return rule; }

		//EQ="==" | NE="!=" | GR=">" | LW="<" | GE=">=" | LE="<=" | LIKE="~"
		public Alternatives getAlternatives() { return cAlternatives; }

		//EQ="=="
		public EnumLiteralDeclaration getEQEnumLiteralDeclaration_0() { return cEQEnumLiteralDeclaration_0; }

		//"=="
		public Keyword getEQEqualsSignEqualsSignKeyword_0_0() { return cEQEqualsSignEqualsSignKeyword_0_0; }

		//NE="!="
		public EnumLiteralDeclaration getNEEnumLiteralDeclaration_1() { return cNEEnumLiteralDeclaration_1; }

		//"!="
		public Keyword getNEExclamationMarkEqualsSignKeyword_1_0() { return cNEExclamationMarkEqualsSignKeyword_1_0; }

		//GR=">"
		public EnumLiteralDeclaration getGREnumLiteralDeclaration_2() { return cGREnumLiteralDeclaration_2; }

		//">"
		public Keyword getGRGreaterThanSignKeyword_2_0() { return cGRGreaterThanSignKeyword_2_0; }

		//LW="<"
		public EnumLiteralDeclaration getLWEnumLiteralDeclaration_3() { return cLWEnumLiteralDeclaration_3; }

		//"<"
		public Keyword getLWLessThanSignKeyword_3_0() { return cLWLessThanSignKeyword_3_0; }

		//GE=">="
		public EnumLiteralDeclaration getGEEnumLiteralDeclaration_4() { return cGEEnumLiteralDeclaration_4; }

		//">="
		public Keyword getGEGreaterThanSignEqualsSignKeyword_4_0() { return cGEGreaterThanSignEqualsSignKeyword_4_0; }

		//LE="<="
		public EnumLiteralDeclaration getLEEnumLiteralDeclaration_5() { return cLEEnumLiteralDeclaration_5; }

		//"<="
		public Keyword getLELessThanSignEqualsSignKeyword_5_0() { return cLELessThanSignEqualsSignKeyword_5_0; }

		//LIKE="~"
		public EnumLiteralDeclaration getLIKEEnumLiteralDeclaration_6() { return cLIKEEnumLiteralDeclaration_6; }

		//"~"
		public Keyword getLIKETildeKeyword_6_0() { return cLIKETildeKeyword_6_0; }
	}
	
	private final ModelElements pModel;
	private final ImportElements pImport;
	private final OperationElements pOperation;
	private final SelectionElements pSelection;
	private final SelectInputElements pSelectInput;
	private final SelectConstaintExpressionElements pSelectConstaintExpression;
	private final BasicSelectConstraintElements pBasicSelectConstraint;
	private final ParenthesisSelectConstraintElements pParenthesisSelectConstraint;
	private final SelectConstraintElements pSelectConstraint;
	private final CompareOperandElements pCompareOperand;
	private final ParameterExpressionElements pParameterExpression;
	private final FilterElements pFilter;
	private final ConstraintExpressionElements pConstraintExpression;
	private final BasicConstraintElements pBasicConstraint;
	private final ParenthesisConstraintElements pParenthesisConstraint;
	private final ConstraintElements pConstraint;
	private final PropertyConstraintElements pPropertyConstraint;
	private final BasicPropertyConstraintElements pBasicPropertyConstraint;
	private final PropertyParenthesisConstraintElements pPropertyParenthesisConstraint;
	private final PropertyValueConstraintElements pPropertyValueConstraint;
	private final TypeSelectionElements pTypeSelection;
	private final ConcreteTypeElements pConcreteType;
	private final TemplateTypeSelectionElements pTemplateTypeSelection;
	private final RecordTypeSelectionElements pRecordTypeSelection;
	private final RecordTypeModifierElements unknownRuleRecordTypeModifier;
	private final SourceReferenceElements pSourceReference;
	private final LiteralElements pLiteral;
	private final ArrayLiteralElements pArrayLiteral;
	private final StringLiteralElements pStringLiteral;
	private final IntLiteralElements pIntLiteral;
	private final FloatLiteralElements pFloatLiteral;
	private final BooleanLiteralElements pBooleanLiteral;
	private final BuiltInValueLiteralElements pBuiltInValueLiteral;
	private final LogicOperatorElements unknownRuleLogicOperator;
	private final ComparatorElements unknownRuleComparator;
	private final QualifiedNameElements pQualifiedName;
	private final QualifiedNameWithWildcardElements pQualifiedNameWithWildcard;
	private final TerminalRule tNUMBER;
	private final TerminalRule tINT;
	private final TerminalRule tFLOAT;
	private final TerminalRule tBOOLEAN;
	
	private final Grammar grammar;

	private final TerminalsGrammarAccess gaTerminals;

	@Inject
	public ConstraintLangGrammarAccess(GrammarProvider grammarProvider,
		TerminalsGrammarAccess gaTerminals) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaTerminals = gaTerminals;
		this.pModel = new ModelElements();
		this.pImport = new ImportElements();
		this.pOperation = new OperationElements();
		this.pSelection = new SelectionElements();
		this.pSelectInput = new SelectInputElements();
		this.pSelectConstaintExpression = new SelectConstaintExpressionElements();
		this.pBasicSelectConstraint = new BasicSelectConstraintElements();
		this.pParenthesisSelectConstraint = new ParenthesisSelectConstraintElements();
		this.pSelectConstraint = new SelectConstraintElements();
		this.pCompareOperand = new CompareOperandElements();
		this.pParameterExpression = new ParameterExpressionElements();
		this.pFilter = new FilterElements();
		this.pConstraintExpression = new ConstraintExpressionElements();
		this.pBasicConstraint = new BasicConstraintElements();
		this.pParenthesisConstraint = new ParenthesisConstraintElements();
		this.pConstraint = new ConstraintElements();
		this.pPropertyConstraint = new PropertyConstraintElements();
		this.pBasicPropertyConstraint = new BasicPropertyConstraintElements();
		this.pPropertyParenthesisConstraint = new PropertyParenthesisConstraintElements();
		this.pPropertyValueConstraint = new PropertyValueConstraintElements();
		this.pTypeSelection = new TypeSelectionElements();
		this.pConcreteType = new ConcreteTypeElements();
		this.pTemplateTypeSelection = new TemplateTypeSelectionElements();
		this.pRecordTypeSelection = new RecordTypeSelectionElements();
		this.unknownRuleRecordTypeModifier = new RecordTypeModifierElements();
		this.pSourceReference = new SourceReferenceElements();
		this.pLiteral = new LiteralElements();
		this.pArrayLiteral = new ArrayLiteralElements();
		this.pStringLiteral = new StringLiteralElements();
		this.pIntLiteral = new IntLiteralElements();
		this.pFloatLiteral = new FloatLiteralElements();
		this.pBooleanLiteral = new BooleanLiteralElements();
		this.pBuiltInValueLiteral = new BuiltInValueLiteralElements();
		this.unknownRuleLogicOperator = new LogicOperatorElements();
		this.unknownRuleComparator = new ComparatorElements();
		this.pQualifiedName = new QualifiedNameElements();
		this.pQualifiedNameWithWildcard = new QualifiedNameWithWildcardElements();
		this.tNUMBER = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "NUMBER");
		this.tINT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "INT");
		this.tFLOAT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "FLOAT");
		this.tBOOLEAN = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "BOOLEAN");
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("org.iobserve.rac.constraint.ConstraintLang".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	
	public Grammar getGrammar() {
		return grammar;
	}
	

	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	//Model:
	//	"package" name=QualifiedName imports+=Import* operations+=Operation*;
	public ModelElements getModelAccess() {
		return pModel;
	}
	
	public ParserRule getModelRule() {
		return getModelAccess().getRule();
	}

	//Import:
	//	"import" importedNamespace=QualifiedNameWithWildcard;
	public ImportElements getImportAccess() {
		return pImport;
	}
	
	public ParserRule getImportRule() {
		return getImportAccess().getRule();
	}

	//// -----------------------------------
	//// filter, selection and composition
	//Operation:
	//	Filter | Selection;
	public OperationElements getOperationAccess() {
		return pOperation;
	}
	
	public ParserRule getOperationRule() {
		return getOperationAccess().getRule();
	}

	//// ---------------------
	//// selection
	//Selection:
	//	"select" name=ID sourceReference=SourceReference ":" inputs+=SelectInput ("," inputs+=SelectInput)* "store"
	//	recordType=[record::RecordType] "(" paremterExpressions+=ParameterExpression (","
	//	paremterExpressions+=ParameterExpression)* ")";
	public SelectionElements getSelectionAccess() {
		return pSelection;
	}
	
	public ParserRule getSelectionRule() {
		return getSelectionAccess().getRule();
	}

	//SelectInput:
	//	recordType=[record::RecordType] name=ID (":" selectConstraint=SelectConstaintExpression)?;
	public SelectInputElements getSelectInputAccess() {
		return pSelectInput;
	}
	
	public ParserRule getSelectInputRule() {
		return getSelectInputAccess().getRule();
	}

	//SelectConstaintExpression:
	//	BasicSelectConstraint (=> ({SelectConstaintExpression.left=current} operator=LogicOperator)
	//	right=SelectConstaintExpression)?;
	public SelectConstaintExpressionElements getSelectConstaintExpressionAccess() {
		return pSelectConstaintExpression;
	}
	
	public ParserRule getSelectConstaintExpressionRule() {
		return getSelectConstaintExpressionAccess().getRule();
	}

	//BasicSelectConstraint returns SelectConstaintExpression:
	//	ParenthesisSelectConstraint | SelectConstraint;
	public BasicSelectConstraintElements getBasicSelectConstraintAccess() {
		return pBasicSelectConstraint;
	}
	
	public ParserRule getBasicSelectConstraintRule() {
		return getBasicSelectConstraintAccess().getRule();
	}

	//ParenthesisSelectConstraint returns SelectConstaintExpression:
	//	"(" constraint=SelectConstaintExpression ")";
	public ParenthesisSelectConstraintElements getParenthesisSelectConstraintAccess() {
		return pParenthesisSelectConstraint;
	}
	
	public ParserRule getParenthesisSelectConstraintRule() {
		return getParenthesisSelectConstraintAccess().getRule();
	}

	//SelectConstraint returns SelectConstaintExpression:
	//	left=CompareOperand comperator=Comparator right=CompareOperand;
	public SelectConstraintElements getSelectConstraintAccess() {
		return pSelectConstraint;
	}
	
	public ParserRule getSelectConstraintRule() {
		return getSelectConstraintAccess().getRule();
	}

	//CompareOperand:
	//	ParameterExpression | Literal;
	public CompareOperandElements getCompareOperandAccess() {
		return pCompareOperand;
	}
	
	public ParserRule getCompareOperandRule() {
		return getCompareOperandAccess().getRule();
	}

	//ParameterExpression:
	//	(input=[SelectInput] ".")? propertyReference=[record::Property];
	public ParameterExpressionElements getParameterExpressionAccess() {
		return pParameterExpression;
	}
	
	public ParserRule getParameterExpressionRule() {
		return getParameterExpressionAccess().getRule();
	}

	//// ------------------------
	//// filter
	//Filter:
	//	"filter" name=ID sourceReference=SourceReference constraint=ConstraintExpression;
	public FilterElements getFilterAccess() {
		return pFilter;
	}
	
	public ParserRule getFilterRule() {
		return getFilterAccess().getRule();
	}

	//ConstraintExpression:
	//	BasicConstraint (=> ({ConstraintExpression.left=current} operator=LogicOperator) right=PropertyConstraint)?;
	public ConstraintExpressionElements getConstraintExpressionAccess() {
		return pConstraintExpression;
	}
	
	public ParserRule getConstraintExpressionRule() {
		return getConstraintExpressionAccess().getRule();
	}

	//BasicConstraint returns ConstraintExpression:
	//	ParenthesisConstraint | Constraint;
	public BasicConstraintElements getBasicConstraintAccess() {
		return pBasicConstraint;
	}
	
	public ParserRule getBasicConstraintRule() {
		return getBasicConstraintAccess().getRule();
	}

	//ParenthesisConstraint returns ConstraintExpression:
	//	"(" constraint=ConstraintExpression ")";
	public ParenthesisConstraintElements getParenthesisConstraintAccess() {
		return pParenthesisConstraint;
	}
	
	public ParserRule getParenthesisConstraintRule() {
		return getParenthesisConstraintAccess().getRule();
	}

	//Constraint returns ConstraintExpression:
	//	typeSelection=TypeSelection propertyConstraint=PropertyConstraint?;
	public ConstraintElements getConstraintAccess() {
		return pConstraint;
	}
	
	public ParserRule getConstraintRule() {
		return getConstraintAccess().getRule();
	}

	//PropertyConstraint:
	//	BasicPropertyConstraint (=> ({PropertyConstraint.left=current} operator=LogicOperator) right=PropertyConstraint)?;
	public PropertyConstraintElements getPropertyConstraintAccess() {
		return pPropertyConstraint;
	}
	
	public ParserRule getPropertyConstraintRule() {
		return getPropertyConstraintAccess().getRule();
	}

	//BasicPropertyConstraint returns PropertyConstraint:
	//	PropertyParenthesisConstraint | PropertyValueConstraint;
	public BasicPropertyConstraintElements getBasicPropertyConstraintAccess() {
		return pBasicPropertyConstraint;
	}
	
	public ParserRule getBasicPropertyConstraintRule() {
		return getBasicPropertyConstraintAccess().getRule();
	}

	//PropertyParenthesisConstraint returns PropertyConstraint:
	//	"(" constraint=PropertyConstraint ")";
	public PropertyParenthesisConstraintElements getPropertyParenthesisConstraintAccess() {
		return pPropertyParenthesisConstraint;
	}
	
	public ParserRule getPropertyParenthesisConstraintRule() {
		return getPropertyParenthesisConstraintAccess().getRule();
	}

	//PropertyValueConstraint returns PropertyConstraint:
	//	property=[record::Property] comparator=Comparator value=Literal;
	public PropertyValueConstraintElements getPropertyValueConstraintAccess() {
		return pPropertyValueConstraint;
	}
	
	public ParserRule getPropertyValueConstraintRule() {
		return getPropertyValueConstraintAccess().getRule();
	}

	//TypeSelection:
	//	ConcreteType | TemplateTypeSelection | RecordTypeSelection;
	public TypeSelectionElements getTypeSelectionAccess() {
		return pTypeSelection;
	}
	
	public ParserRule getTypeSelectionRule() {
		return getTypeSelectionAccess().getRule();
	}

	//ConcreteType:
	//	type=[record::Type];
	public ConcreteTypeElements getConcreteTypeAccess() {
		return pConcreteType;
	}
	
	public ParserRule getConcreteTypeRule() {
		return getConcreteTypeAccess().getRule();
	}

	//TemplateTypeSelection:
	//	"?" "uses" types+=[record::TemplateType] ("," types+=[record::TemplateType|QualifiedName])*;
	public TemplateTypeSelectionElements getTemplateTypeSelectionAccess() {
		return pTemplateTypeSelection;
	}
	
	public ParserRule getTemplateTypeSelectionRule() {
		return getTemplateTypeSelectionAccess().getRule();
	}

	//RecordTypeSelection:
	//	"?" modifier=RecordTypeModifier type=[record::RecordType];
	public RecordTypeSelectionElements getRecordTypeSelectionAccess() {
		return pRecordTypeSelection;
	}
	
	public ParserRule getRecordTypeSelectionRule() {
		return getRecordTypeSelectionAccess().getRule();
	}

	//enum RecordTypeModifier:
	//	SUPER="super" | EXTENDS="extends";
	public RecordTypeModifierElements getRecordTypeModifierAccess() {
		return unknownRuleRecordTypeModifier;
	}
	
	public EnumRule getRecordTypeModifierRule() {
		return getRecordTypeModifierAccess().getRule();
	}

	//// -----------------------------------
	//// Common rules
	//SourceReference:
	//	"from" (filter=[Operation] | default?="default");
	public SourceReferenceElements getSourceReferenceAccess() {
		return pSourceReference;
	}
	
	public ParserRule getSourceReferenceRule() {
		return getSourceReferenceAccess().getRule();
	}

	//// TODO we might replace default by a distinct selection of different inputs
	//// -----------------------------------
	//// Literal
	//Literal:
	//	StringLiteral | IntLiteral | FloatLiteral | BooleanLiteral | ArrayLiteral | BuiltInValueLiteral;
	public LiteralElements getLiteralAccess() {
		return pLiteral;
	}
	
	public ParserRule getLiteralRule() {
		return getLiteralAccess().getRule();
	}

	//ArrayLiteral:
	//	"{" literals+=Literal ("," literals+=Literal)* "}";
	public ArrayLiteralElements getArrayLiteralAccess() {
		return pArrayLiteral;
	}
	
	public ParserRule getArrayLiteralRule() {
		return getArrayLiteralAccess().getRule();
	}

	//StringLiteral:
	//	value=STRING;
	public StringLiteralElements getStringLiteralAccess() {
		return pStringLiteral;
	}
	
	public ParserRule getStringLiteralRule() {
		return getStringLiteralAccess().getRule();
	}

	//IntLiteral:
	//	value=INT;
	public IntLiteralElements getIntLiteralAccess() {
		return pIntLiteral;
	}
	
	public ParserRule getIntLiteralRule() {
		return getIntLiteralAccess().getRule();
	}

	//FloatLiteral:
	//	value=FLOAT;
	public FloatLiteralElements getFloatLiteralAccess() {
		return pFloatLiteral;
	}
	
	public ParserRule getFloatLiteralRule() {
		return getFloatLiteralAccess().getRule();
	}

	//BooleanLiteral:
	//	value=BOOLEAN;
	public BooleanLiteralElements getBooleanLiteralAccess() {
		return pBooleanLiteral;
	}
	
	public ParserRule getBooleanLiteralRule() {
		return getBooleanLiteralAccess().getRule();
	}

	//BuiltInValueLiteral:
	//	{BuiltInValueLiteral} value="KIEKER_VERSION";
	public BuiltInValueLiteralElements getBuiltInValueLiteralAccess() {
		return pBuiltInValueLiteral;
	}
	
	public ParserRule getBuiltInValueLiteralRule() {
		return getBuiltInValueLiteralAccess().getRule();
	}

	//// -----------------------------------
	//// Terminals
	//enum LogicOperator:
	//	AND="&" | OR="|";
	public LogicOperatorElements getLogicOperatorAccess() {
		return unknownRuleLogicOperator;
	}
	
	public EnumRule getLogicOperatorRule() {
		return getLogicOperatorAccess().getRule();
	}

	//enum Comparator:
	//	EQ="==" | NE="!=" | GR=">" | LW="<" | GE=">=" | LE="<=" | LIKE="~";
	public ComparatorElements getComparatorAccess() {
		return unknownRuleComparator;
	}
	
	public EnumRule getComparatorRule() {
		return getComparatorAccess().getRule();
	}

	//QualifiedName:
	//	ID ("." ID)*;
	public QualifiedNameElements getQualifiedNameAccess() {
		return pQualifiedName;
	}
	
	public ParserRule getQualifiedNameRule() {
		return getQualifiedNameAccess().getRule();
	}

	//QualifiedNameWithWildcard:
	//	QualifiedName ("." "*")?;
	public QualifiedNameWithWildcardElements getQualifiedNameWithWildcardAccess() {
		return pQualifiedNameWithWildcard;
	}
	
	public ParserRule getQualifiedNameWithWildcardRule() {
		return getQualifiedNameWithWildcardAccess().getRule();
	}

	//// terminals
	//terminal fragment NUMBER:
	//	"0".."9";
	public TerminalRule getNUMBERRule() {
		return tNUMBER;
	} 

	//// redefine INT terminal to allow negative numbers
	//terminal INT returns ecore::EInt:
	//	"-"? NUMBER+;
	public TerminalRule getINTRule() {
		return tINT;
	} 

	//// make sure the Float rule does not shadow the INT rule
	//terminal FLOAT returns ecore::EFloatObject:
	//	"-"? NUMBER+ ("." NUMBER*) (("e" | "E") ("+" | "-")? NUMBER+)? "f"? | "-"? NUMBER+ "f";
	public TerminalRule getFLOATRule() {
		return tFLOAT;
	} 

	//// introduce boolean values
	//terminal BOOLEAN returns ecore::EBooleanObject:
	//	"true" | "false";
	public TerminalRule getBOOLEANRule() {
		return tBOOLEAN;
	} 

	//terminal ID:
	//	"^"? ("a".."z" | "A".."Z" | "_") ("a".."z" | "A".."Z" | "_" | "0".."9")*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	} 

	//terminal STRING:
	//	"\"" ("\\" . / * 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' * / | !("\\" | "\""))* "\"" | "\'" ("\\" .
	//	/ * 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' * / | !("\\" | "\'"))* "\'";
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	} 

	//terminal ML_COMMENT:
	//	"/ *"->"* /";
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	} 

	//terminal SL_COMMENT:
	//	"//" !("\n" | "\r")* ("\r"? "\n")?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	} 

	//terminal WS:
	//	(" " | "\t" | "\r" | "\n")+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	} 

	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	} 
}
